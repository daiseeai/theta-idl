{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleContexts          #-}
{-# LANGUAGE LambdaCase                #-}
{-# LANGUAGE MultiParamTypeClasses     #-}
{-# LANGUAGE NamedFieldPuns            #-}
{-# LANGUAGE OverloadedStrings         #-}
{-# LANGUAGE QuasiQuotes               #-}
{-# LANGUAGE RecordWildCards           #-}
{-# LANGUAGE StandaloneDeriving        #-}
{-# LANGUAGE ViewPatterns              #-}

-- | The core set of errors that can be encountered when working with
-- Theta defintions.
module Theta.Error
  ( ParseError
  , Error (..)
  , TargetError (..)
  , throw
  , unsafe

  , ModuleError (..)
  , prettyModuleError

  , Suggestion (..)
  , renderedSuggestions
  , renderSuggestions
  , nameSuggestions
  , primitiveSuggestions
  , otherModuleSuggestions
  , similarSpellingSuggestions

  , diffParts
  )
where

import           Control.Exception.Base    (Exception (..), displayException)
import           Control.Monad.Except      (MonadError, throwError)

import qualified Data.Algorithm.Diff       as Diff
import           Data.Containers.ListUtils (nubOrd)
import           Data.Function             (on)
import           Data.List                 (sortOn)
import qualified Data.Map                  as Map
import qualified Data.Set                  as Set
import           Data.Text                 (Text)
import qualified Data.Text                 as Text
import           Data.Void                 (Void)

import qualified Text.Megaparsec           as Megaparsec

import           Theta.LoadPath            (LoadPath)
import           Theta.Metadata            (Metadata, Version)
import qualified Theta.Metadata            as Metadata
import           Theta.Name                (ModuleName, Name)
import qualified Theta.Name                as Name
import           Theta.Pretty              (Pretty (..), indentBy, pr,
                                            prettyList)
import           Theta.Primitive           (primitives)
import qualified Theta.Primitive           as Primitive
import           Theta.Types               (FieldName, Module)
import qualified Theta.Types               as Theta
import           Theta.Versions            (Range (..))


-- * Core Errors

-- | The kind of error generated by Theta's parser.
type ParseError = Megaparsec.ParseErrorBundle Text Data.Void.Void

-- | Errors encountered when working with Theta defintions.
--
-- The 'target' parameter lets us include errors specific to an
-- input/output target (like Avro or Haskell).
data Error = ParseError ParseError
             -- ^ A parse error raised by parsec.
           | IOError IOError
             -- ^ An error in reading or writing files
             -- (including importing modules).
           | UnsupportedVersion Metadata Range Version
             -- ^ A module requires a language or encoding version
             -- that is not supported by this release of Theta.
           | InvalidModule [(Module, ModuleError)]
             -- ^ The module or its dependencies have
             -- validation errors. This includes the errors for
             -- /every/ invalid module, tagged with the name of
             -- the module.
           | InvalidName Text
             -- ^ The given name is not syntactically valid.
           | UnqualifiedName Text
             -- ^ The given name does not have a namespace where a
             -- namespace is required.
           | MissingModule LoadPath ModuleName
             -- ^ The given module was not found.
           | MissingName Name
             -- ^ The given fully-qualified name was not found.
           | Target Text TargetError
             -- ^ An error specific to a target, along with the
             -- name of the target itself.
             --
             -- For example, we can't export types other than
             -- records or variants as a schema in Avro. Trying
             -- to do this would raise the following error:
             --
             -- @
             -- Target "Avro" (InvalidExport <type>)
             -- @
           deriving (Show)

instance Exception Error where displayException = Text.unpack . pretty

-- | A wrapper for some type of error generated by a target-specific
-- operation in Theta—errors specific to encoding to/from Avro,
-- converting between Haskell types...etc.
--
-- This error is wrapped in an existential type so that operations on
-- different targets can be composed. For example, we can combine
-- 'fromAvro' (which raises Avro-specific errors) with 'fromTheta'
-- (which raises type mismatch errors) to go from the Avro binary
-- format to Haskell types.
data TargetError =
  forall error. (Show error, Pretty error) => TargetError error

deriving instance Show TargetError

-- | Throw an error specific to a particular target (Avro, Haskell…
-- etc).
throw :: (Show error, Pretty error, MonadError Error m)
      => Text
         -- ^ The name of the target that causes this error ("Avro",
         -- "Haskell"… etc).
      -> error
      -> m a
throw targetName = throwError . Target targetName . TargetError

-- | Unsafely extract a value that might be a Theta 'Error', turning
-- errors into runtime exceptions.
--
-- This is meant to be used when the error represents a bug in Theta
-- itself as opposed to an issue with an input.
unsafe :: Either Error a -> a
unsafe = \case
  Left err  -> error $ Text.unpack $ pretty err
  Right res -> res
               -- Consider: Add a note to the error message that this
               -- is a bug that should be reported on GitHub

instance Pretty Error where
  pretty = \case
    ParseError err -> Text.pack $ Megaparsec.errorBundlePretty err
    IOError err    -> Text.pack $ displayException err

    UnsupportedVersion metadata range version ->
      [pr|
        The ‘{pretty $ Metadata.moduleName metadata}’ module requires

          {name range} = {pretty version}

        but this release of Theta only supports

          {name range} ≥ {pretty $ lower range} and < {pretty $ upper range}
        |]
    InvalidModule errs ->
      [pr|
        Errors in module definitions:

        {Text.intercalate "\n" $ prettyModuleError <$> errs}
        |]
    InvalidName name ->
      [pr|
        Syntax error: ‘{name}’ is not a valid Theta name.
        |]
    UnqualifiedName name ->
      [pr|
        ‘{name}’ does not have a namespace. Please provide
        a fully-qualified name like ‘com.example.Foo’.
        |]
    MissingModule loadPath moduleName ->
      [pr|
        The module ‘{pretty moduleName}’ was not found in load path ‘{pretty loadPath}’.
        |]
    MissingName Name.Name { Name.name, Name.moduleName } ->
      [pr|
        Could not find ‘{pretty name}’ in module ‘{pretty moduleName}’.
        |]

    Target target (TargetError err) ->
        [pr|
          Error converting to/from {target}:

          {pretty err}
          |]

-- * Module Validation

-- $ When we load a Theta module, we go through the entire module
-- collecting "recoverable" errors: missing identifiers, duplicate
-- names... etc. Ideally, this pass should collect all the errors that
-- don't stop us from processing the rest of the module (unlike, say,
-- parse errors) so that we can present them to the user all at once.
--
-- Right now these errors are collected one module at a time, but in
-- the future we should be able to collect them for /all/ the modules
-- being processed, including transitive imports. This will help with
-- better error-reporting from the command-line tool as well as
-- interactive tooling (eg theta lsp) if we ever implement it.

-- | Errors caught when validating a module that has already been
-- parsed. These are errors at the "Theta language" level: conflicting
-- or undefined names, duplicate record fields... etc.
data ModuleError =
    --                  record  field
    --                    ↓       ↓
    DuplicateRecordField Name FieldName
    -- ^ The record with the given name has more than one field with the
    -- same name.

    --              variant case
    --                 ↓     ↓
  | DuplicateCaseName Name Name
    -- ^ The variant with the given name has more than one case with
    -- the same name.

    --                variant  case  field
    --                   ↓      ↓      ↓
  | DuplicateCaseField Name   Name FieldName
    -- ^ A variant with a case that has multiple fields with the same
    -- name.

  | UndefinedType Name
    -- ^ A name used in the module has not been defined.

  | DuplicateTypeName Name
    -- ^ A type with the given name has been defined multiple times in
    -- the same module. Fully qualified names (that is, name +
    -- namespace) should be *globally unique* in a Theta module.
    --
    -- Note: types, fields and variant constructors do not share a
    -- namespace, so you can use the same name for a type /and/ a
    -- constructor in traditional Haskell style.
    deriving (Show)

-- | Creates a readable message for a single module error, noting both
-- the problem and the module it originates from.
prettyModuleError :: (Module, ModuleError) -> Text
prettyModuleError (containingModule, err) =
  [pr|Error in module ‘{pretty containingName}’:|] <> "\n" <> message
    where
      containingName = Theta.moduleName containingModule

      message :: Text
      message = case err of
        DuplicateRecordField record field ->
          [pr|The record ‘{pretty record}’ has multiple fields called ‘{pretty field}’.|]

        DuplicateCaseName variant case_ ->
          [pr|The variant ‘{pretty variant}’ has multiple cases called ‘{pretty case_}’|]

        DuplicateCaseField variant case_ field ->
          [pr|The case ‘{pretty case_}’ of the variant ‘{pretty variant}’ has multiple fields called ‘{pretty field}’.|]

        UndefinedType name ->
          let suggestions = renderedSuggestions containingModule name
              base = [pr|The type ‘{pretty name}’ is not defined.|]
          in case suggestions of
             [] -> base
             _  -> base
                <> "\n\n"
                <> "Suggestions:\n"
                <> indentBy 2 (prettyList suggestions)

        DuplicateTypeName name ->
          [pr|
            The type ‘{pretty name}’ has been defined multiple times.

            Fully qualified names have to be globally unique in Theta schemas.
            |]

-- ** Name Suggestions

-- $ If a name used in a module could not be found, we can come up
-- with possible suggestions in a few different ways, then display all
-- of those suggestions in the error message.
--
-- In the future, this will also be useful for interactive tools,
-- where we can supply suggestions for automatic fixes.

-- | A suggestion, which can either be a name (for other types defined
-- in Theta) or a primitive type.
data Suggestion = SuggestPrimitive Primitive.Primitive
                | SuggestName Name
  deriving (Show, Eq)

-- | Render suggestions for an out-of-scope name to a list of
-- human-readable strings.
--
-- See 'renderSuggestions' for details about the human-readable rendering.
--
-- See 'nameSuggestions' for details about the suggestions themselves.
renderedSuggestions :: Module -> Name -> [Text]
renderedSuggestions module_ = renderSuggestions module_ . nameSuggestions module_

-- | Render a list of suggestions into a list of human-readable
-- descriptions. The order of the suggestions isn't changed.
--
-- A suggestion might be rendered with additional text. For example, a
-- suggestion for the primitive type @UUID@ becomes:
--
-- @
-- UUID (primitive type): requires language-version ≥ 1.1.0
-- @
--
-- A suggestion for @example.Foo@ that needs to be imported becomes:
--
-- @
-- example.Foo (import Foo)
-- @
--
-- A suggestion for the current module becomes:
--
-- @
-- Foo (example.Foo)
-- @
renderSuggestions :: Module -> [Suggestion] -> [Text]
renderSuggestions module_ = map render
  where render (SuggestPrimitive primitive) =
          let minVersion = Primitive.definedIn primitive in [pr|
            {pretty primitive} (primitive type): requires language-version ≥ {pretty minVersion}
          |]

        render (SuggestName fullName@Name.Name {..})
          | moduleName == containingName =
             [pr|{name} ({pretty fullName})|]
          | Set.member moduleName directImports =
             pretty fullName
          | otherwise =
             [pr|{pretty fullName} (import {pretty moduleName})|]
        directImports = Set.fromList $ Theta.moduleName <$> Theta.imports module_

        containingName = Theta.moduleName module_

-- | Suggestions, with each line formatted in a readable style.
--
-- Each line will include not only the name being suggested but also
-- any additional information (hints about imports needed, notes on
-- version requirements... etc).
--
-- Suggested names are deduplicated, then grouped by the following
-- logic:
--
--   * primitive types first
--   * types suggested from current module (prefix optional)
--   * types suggested from other modules
nameSuggestions :: Module -> Name -> [Suggestion]
nameSuggestions module_ name = primitives <> organize suggestedNames
  where primitives = SuggestPrimitive <$> primitiveSuggestions module_ name

        suggestedNames = otherModuleSuggestions module_ name
                      <> similarSpellingSuggestions 4 module_ name
                       -- maxDistance = 4 is arbitrary, could be tuned

        organize (nubOrd -> names) = SuggestName <$> sortOn grouping names
        grouping Name.Name { Name.moduleName }
          | moduleName == Theta.moduleName module_ = 1
          | otherwise                              = 2

-- | If a name overlaps with a primitive type, but the
-- @language-version@ for the module does not support the primitive
-- type, add a suggestion:
--
-- @
-- UUID (primitive type): requires language-version ≥ 1.1.0
-- @
primitiveSuggestions :: Module -> Name -> [Primitive.Primitive]
primitiveSuggestions module_ Name.Name { Name.name } = case Map.lookup name primitiveNames of
  Just primitive -> [primitive | version < Primitive.definedIn primitive]
  _              -> []
  where version = Metadata.languageVersion $ Theta.metadata module_
        primitiveNames = Map.fromList [(pretty p, p) | p <- primitives]

-- | Names whose base names match the given name /exactly/, but have a
-- different namespace. The order names are returned is unspecified.
--
-- This function searches through the transitive imports of the given
-- module and will suggest both imported and unimported names.
--
-- If @example.User@ is not available, this would:
--
--  * suggest @example.user.User@ if available
--  * /not/ suggest @example.Users@ or @example.user.Users@
otherModuleSuggestions :: Module
                       -- ^ Searches through the names defined in this module as
                       -- well as all of its transitive imports.
                       -> Name
                       -- ^ The name to compare against.
                       -> [Name]
otherModuleSuggestions module_  Name.Name { Name.name = expected } =
  filter isExpected $ Set.toList $ Theta.allNames module_
  where isExpected n = Name.name n == expected

-- | Names that are "close" in spelling to the given name, sorted from
-- most to least similar. This accounts for two kinds of typos:
--
--  1. Typos in the base name or a namespace components
--  2. Dropping namespace components
--
-- We diff the /parts/ of a name, treating any part that's within
-- @maxDistance@ characters as equal. A name is similar if all the
-- parts match up in this pass or it requires /either/ adding or
-- removing parts but /not/ both.
--
-- Names are returned sorted by the sums of the distances between
-- their components, with each added/removed component counting as a
-- single operation.
--
-- This function searches through the transitive imports of the given
-- module and will suggest both imported and unimported names.
similarSpellingSuggestions :: Int
                           -- ^ Maximum edit distance for two components to
                           -- "count" as the same.
                           -> Module
                           -- ^ Searches through the names defined in this module
                           -- as well as all of its transitive imports.
                           -> Name
                           -- ^ The name to compare against.
                           -> [Name]
similarSpellingSuggestions maxDistance module_ expected = sortOn sortDistance similar
  where sortDistance name = sum $ partDistance <$> diffParts maxDistance expected name

        partDistance (Diff.Both a b)  = sum $ zipWith textDistance a b
        partDistance (Diff.First ps)  = length ps
        partDistance (Diff.Second ps) = length ps

        similar = filter isSimilar $ Set.toList $ Theta.allNames module_
        isSimilar name = count isFirst diff == 0 || count isSecond diff == 0
          where diff = diffParts maxDistance expected name

        isFirst Diff.First {} = True
        isFirst _             = False

        isSecond Diff.Second {} = True
        isSecond _              = False

-- | Diff the parts (namespace components + base name) of two names,
-- treating any part within @maxDistance@ edit distance as equivalent.
--
-- The edit distance for two parts is compared on a
-- character-by-character basis, with additions and removals each
-- counting as one operation. (See 'textDistance'.)
--
-- All parts within the distance:
-- >>> diffParts 2 "foo.bar.baz" "foo.bar.baze"
-- [Both ["foo","bar","baz"] ["foo","bar","baze"]]
--
-- Adding a part:
-- >>> diffParts 2 "foo.bar" "foo.bar.baz"
-- [Both ["foo","bar"] ["foo","bar"],Second ["baz"]]
--
-- Two parts that are too different:
-- >>> diffParts 2 "foo.bar.baz" "foo.bar.bats"
-- [Both ["foo","bar"] ["foo","bar"],First ["baz"],Second ["bats"]]
diffParts :: Int -> Name -> Name -> [Diff.Diff [Text]]
diffParts maxDistance = Diff.getGroupedDiffBy withinMax `on` Name.parts
  where withinMax a b = textDistance a b <= maxDistance

-- | The edit distance between two strings.
--
-- Text distance is calculated character-by-character. An addition or
-- removal counts for 1. There is no "modify" operation, so changing a
-- character counts for 2.
--
-- >>> textDistance "cat" "cats"
-- 1
--
-- >>> textDistance "cat" "bat"
-- 2
--
-- >>> textDistance "cat" "bats"
-- 3
textDistance :: Text -> Text -> Int
textDistance a b = count (not . both) $ Diff.getDiff (Text.unpack a) (Text.unpack b)
  where both Diff.First{}  = False
        both Diff.Second{} = False
        both Diff.Both{}   = True

-- | The number of elements in a list that match a predicate.
--
-- >>> count (== 'a') "aaaabaac"
-- 6
count :: (a -> Bool) -> [a] -> Int
count f = length . filter f
